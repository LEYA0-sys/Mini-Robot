# 图像识别

## 1.人脸识别实现原理

1. **系统架构**：
   - 使用AppFace类作为主要实现类，采用观察者模式与其他组件（按键、语音、相机、显示）交互
   - 采用基于队列的图像数据流处理方式，多个组件间通过队列传递数据
2. **人脸检测**：
   - 使用两级检测器：HumanFaceDetectMSR01（主检测器）和HumanFaceDetectMNP01（细化检测器）
   - MSR01负责初步检测可能的人脸区域，生成候选框
   - MNP01对候选框进行二次筛选，提高准确性
3. **人脸识别流程**：
   - 图像获取：从相机获取RGB565格式的图像帧
   - 人脸检测：使用两级检测器检测人脸位置和关键点
   - 人脸对齐：基于关键点对人脸进行对齐（align_face函数）
   - 特征提取：使用FaceRecognition112V1S8/S16模型提取人脸特征向量
   - 特征匹配：计算特征向量与已注册人脸的余弦相似度，判断身份
4. **操作模式**：
   - 人脸注册（FACE_ENROLL）：注册新的人脸ID到系统
   - 人脸识别（FACE_RECOGNIZE）：识别当前人脸并匹配已注册ID
   - 删除人脸（FACE_DELETE）：删除已注册的人脸ID
   - 空闲状态（FACE_IDLE）：系统不执行特定人脸操作
5. **模型与算法**：
   - 使用轻量级神经网络进行人脸检测与特征提取
   - 使用余弦相似度（cosine similarity）进行特征匹配
   - 支持两种精度模式：S8（8位量化）和S16（16位量化）
   - 相似度阈值控制（默认0.98）：高于此值视为同一人
6. **数据存储**：
   - 人脸特征向量存储在ESP32的Flash分区中（名为"fr"的分区）
   - 支持人脸ID的持久化存储和加载

此示例展示了如何在资源受限的ESP32平台上实现轻量级但功能完整的人脸识别系统，整合了视觉、语音和按键交互，提供了注册、识别和管理人脸的完整功能。



这个人脸识别系统是**完全在ESP32本地实现**的，没有使用服务器端AI。

1. 整个识别流程都在ESP32设备上执行，包括：
   - 人脸检测（使用HumanFaceDetectMSR01和HumanFaceDetectMNP01本地模型）
   - 人脸特征提取（使用FaceRecognition112V1S8/S16本地模型）
   - 人脸匹配（本地计算余弦相似度）

2. 人脸特征数据存储在ESP32自身的Flash分区中（"fr"分区）

3. 代码中没有任何网络通信、HTTP请求或云服务API调用

这是ESP32-S3等AI芯片的优势之一，可以在资源受限的嵌入式设备上本地运行轻量级神经网络模型，无需依赖云服务，实现完全离线的AI功能。



## 2.YOLO实现原理

这个YOLO演示程序是一个完全在ESP32本地执行的目标检测系统，不需要服务器端AI支持。这个示例使用了YOLOv11n模型，一个为ESP32芯片优化的轻量级目标检测模型，支持识别COCO数据集中的80种常见物体（如人、车、动物等）。

关键特点：

1. **完全本地推理**：
   - 所有模型推理完全在ESP32芯片上执行，无需网络连接
   - 模型可以存储在Flash中（rodata或专用分区）或SD卡上

2. **优化的模型**：
   - 使用YOLOv11n（YOLO的轻量级版本），经过量化优化适配ESP32资源限制
   - 提供多种模型变体（V1/V2/V3）和不同输入尺寸（320x320或640x640）
   - 根据README显示，模型大小为8-16MB，在ESP32-S3上运行时间为几秒到数十秒

3. **量化技术**：
   - 使用8位量化（S8）降低内存需求
   - 支持混合精度量化和量化感知训练等优化技术

4. **工作流程**：
   - 从摄像头获取图像
   - 预处理图像（缩放、归一化）
   - 通过YOLOv11n模型进行推理
   - 后处理检测结果（过滤低置信度框、应用NMS等）
   - 在显示屏上渲染结果（标注检测框和类别名称）

5. **模式控制**：
   - 通过按钮切换摄像头显示模式和AI检测模式
   - 长按按钮可以强制返回摄像头模式（紧急重置）

与之前的人脸识别示例类似，这个YOLO演示是展示ESP32芯片在资源受限环境下执行复杂AI任务的能力，完全不依赖于云服务或服务器端处理。



## 3.摄像头图片数据

`camera_fb_t *frame = esp_camera_fb_get();` 这一行代码就是获取相机图像数据的核心操作。`esp_camera_fb_get()`函数返回一个指向`camera_fb_t`结构体的指针，这个结构体包含了完整的相机帧缓冲区。

`camera_fb_t`是ESP32相机驱动中定义的帧缓冲区结构体，它包含以下成员：

```c
typedef struct {
    uint8_t * buf;              // 指向图像数据的指针
    size_t len;                 // 图像数据的长度(字节数)
    size_t width;               // 图像宽度(像素)
    size_t height;              // 图像高度(像素)
    pixformat_t format;         // 像素格式(例如PIXFORMAT_RGB565, PIXFORMAT_JPEG等)
    struct timeval timestamp;   // 帧捕获的时间戳
} camera_fb_t;
```

在人脸识别示例中：

1. `buf`字段指向RGB565格式的图像数据(每个像素用2字节表示)
2. 图像尺寸为240x240像素(这是在app_main.cpp中设置的)
3. 数据总大小约为115KB(240x240x2字节)

这个结构体提供了访问原始图像数据所需的所有信息:

- 你可以通过`frame->buf`访问原始的RGB565像素数据
- 通过`frame->width`和`frame->height`获取图像尺寸
- 通过`frame->format`确认像素格式(RGB565、JPEG等)

使用完图像数据后，应当调用`esp_camera_fb_return(frame)`归还这个帧缓冲区，或者如果你自己处理内存，则使用`free(frame)`释放它。



## 4.RGB565

RGB565 是一种用于表示数字图像颜色的**16位（2字节）色彩编码格式**，广泛应用于嵌入式系统、显示屏驱动和图像处理中（尤其在资源受限的设备）。其核心设计是在有限的存储空间内平衡色彩质量和内存占用。

---

###  一、格式结构解析

RGB565 将每个像素的颜色分解为**红（R）、绿（G）、蓝（B）** 三个通道，并按以下位宽分配：

```
| 15        11 | 10         5 | 4          0 |
|--------------|--------------|--------------|
|   Red (5位)  | Green (6位)  |  Blue (5位)  |
```

- **红色（R）**：占用 **5位**（取值范围 `0~31`）  
- **绿色（G）**：占用 **6位**（取值范围 `0~63`）  
- **蓝色（B）**：占用 **5位**（取值范围 `0~31`）  

> 📌 **为什么绿色多1位？**  
> 人眼对绿色更敏感，增加绿色分辨率可提升视觉感知的自然度。

---

###  二、开发中的操作

#### 1. **像素读写（C语言示例）**

```c
// 将RGB值打包为RGB565格式
uint16_t rgb565 = ((r & 0x1F) << 11) | ((g & 0x3F) << 5) | (b & 0x1F);

// 从RGB565解析颜色
uint8_t r = (rgb565 >> 11) & 0x1F;  // 提取高5位
uint8_t g = (rgb565 >> 5)  & 0x3F;  // 提取中间6位
uint8_t b = rgb565 & 0x1F;           // 提取低5位
```

---

###  总结

RGB565 是嵌入式领域的**高效色彩妥协方案**：  
✅ **优势**：节省33~50%内存/带宽，满足多数场景的色彩需求。  
❌ **劣势**：不适合摄影级图像处理。  
在ESP32等物联网设备中，它是摄像头采集、LCD显示的首选格式，直接影响系统性能与功耗。



# WSL+VScode的esp环境开发

https://blog.csdn.net/m0_67862631/article/details/148105239?fromshare=blogdetail&sharetype=blogdetail&sharerId=148105239&sharerefer=PC&sharesource=2302_80024781&sharefrom=from_link

https://blog.csdn.net/m0_67862631/article/details/148118009?fromshare=blogdetail&sharetype=blogdetail&sharerId=148118009&sharerefer=PC&sharesource=2302_80024781&sharefrom=from_link

具体步骤参考这两篇文章

操作完之后速度起飞，还能用**VScode图形化编译烧录**





![image-20250714141743608](./7%E6%9C%8814%E6%97%A5%E8%AE%B0%E5%BD%95.assets/image-20250714141743608.png)

![image-20250714142413844](./7%E6%9C%8814%E6%97%A5%E8%AE%B0%E5%BD%95.assets/image-20250714142413844.png)





用5.4.1的IDF运行出现问题，I2C驱动冲突

之后使用5.3.3也有这样的问题

同时我直接烧录商家给的固件也有问题

![image-20250714181239895](./7%E6%9C%8814%E6%97%A5%E8%AE%B0%E5%BD%95.assets/image-20250714181239895.png)

![img](./7%E6%9C%8814%E6%97%A5%E8%AE%B0%E5%BD%95.assets/O1CN01NdcR3e1XdmHOODQfp_!!2218551232947-2-ampmedia.png)

商家说只有这三个固件是能用的





在task中持续打印这个数据太多了，esp直接一直重启，且这个数据量很大，我拿到格式数据就好了



烧录之后没来由的无法唤醒，只能识别第一次，似乎是麦克风的原因。后面好一点了



一说人脸识别，他就重启。准备把esp IDF的版本降级了，可能不是这个原因



