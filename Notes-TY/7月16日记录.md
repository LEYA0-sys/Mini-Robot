# **7月16日记录**

## 重点：RGB565格式的数据量大，带宽要求高。JPEG格式有点模糊啊

![21fd6f8657c2aff1211a479e6b3e230](./7%E6%9C%8816%E6%97%A5%E8%AE%B0%E5%BD%95.assets/21fd6f8657c2aff1211a479e6b3e230.jpg)



前端是通过 WebSocket 实时接收 JPEG 二进制流，转为 Blob 后用 URL.createObjectURL 生成图片 URL，赋值给 img 的 src 属性进行显示。这是处理二进制 JPEG 数据并在网页上显示的标准做法。

![image-20250717004757871](./7%E6%9C%8816%E6%97%A5%E8%AE%B0%E5%BD%95.assets/image-20250717004757871.png)

这个以 `blob:http://192.168.4.1/...` 开头的字符串是一个 **Blob URL (或 Object URL)**。它是在 **浏览器环境** 中，通过 JavaScript API (`URL.createObjectURL()`) 动态创建的一个**临时 URL**，用于引用浏览器内存中或本地生成的 **Blob 对象** 或 **File 对象**。







![image-20250717012731287](./7%E6%9C%8816%E6%97%A5%E8%AE%B0%E5%BD%95.assets/image-20250717012731287.png)

 jpeg_buf_len 长度不一致是正常现象，原因如下：

------

### 1. 每一帧图像内容不同

- 摄像头每次采集到的画面内容都不一样（比如光线、颜色、运动、细节等），

- JPEG 压缩算法会根据内容复杂度动态调整压缩比，内容越复杂，压缩后数据越大，内容越简单，数据越小。

------

### 2. JPEG压缩本身是有损且自适应的

- JPEG 压缩不是定长输出，压缩后长度和原始内容相关。

- 比如一帧全黑，压缩后很小；一帧细节丰富，压缩后会大很多。

------

### 3. 分辨率、质量参数也会影响

- 调用 frame2jpg(fb, 80, &jpeg_buf, &jpeg_buf_len);，这里的 80 是压缩质量，质量越高，jpeg_buf_len 越大。

- 分辨率越高，jpeg_buf_len 也会越大。

------

### 4. 总结

- 只要摄像头采集的内容在变化，jpeg_buf_len 每一帧都可能不同，这完全正常。

- 只要没有出现异常小（比如只有几十字节）或者异常大（超出摄像头分辨率极限）的长度，就不用担心。

​      **JPEG文件本质上就是一个二进制流：**

- 当你保存一个`.jpg`或`.jpeg`文件时，JPEG编码器会按照JPEG标准，将图像信息压缩并组织成一个特定的二进制序列（0和1的流）。









| 传输模式        | 文件大小 | 图像质量 | 网络带宽 | CPU使用 |
| --------------- | -------- | -------- | -------- | ------- |
| **当前JPEG-80** | ~15KB    | 有损失   | 低       | 中等    |
| **优化JPEG-90** | ~20KB    | 轻微损失 | 低       | 中等    |
| **RGB565原始**  | ~115KB   | 无损失   | 高       | 低      |





## 摄像头数据通过WebSocket传输的完整流程

### 1. **系统初始化**

```
在主程序中，系统按以下顺序初始化：

/* Initialize the camera */
const camera_config_t camera_config = BSP_CAMERA_DEFAULT_CONFIG;
err = esp_camera_init(&camera_config);
if (err != ESP_OK) {
    ESP_LOGE(TAG, "Camera Init Failed");
    return;
}

wifi_init_ap();
start_webserver();
```





### 2. **WebSocket连接建立**

当客户端连接到 `/ws` 端点时，WebSocket握手完成后会自动启动视频流：

```
if (req->method == HTTP_GET) {

  ESP_LOGI(TAG, "WS Handshake done, the new connection was opened.");

  start_ws_stream();

  return ESP_OK;

}
```



### 3. **视频流任务核心逻辑**

`ws_stream_task` 是核心的视频流处理任务：

```
static void ws_stream_task(void *param) {

  while (ws_stream_task_running) {

    // 1. 获取摄像头帧缓冲

    fb = esp_camera_fb_get();
    

    // 2. 转换为JPEG格式

    if (fb->format != PIXFORMAT_JPEG) {

      bool jpeg_converted = frame2jpg(fb, 80, &jpeg_buf, &jpeg_buf_len);

    } else {

      jpeg_buf = fb->buf;

      jpeg_buf_len = fb->len;

    }

    
    // 3. 通过WebSocket发送JPEG数据

    esp_err_t res = ws_async_send_image(jpeg_buf, jpeg_buf_len);

    
    // 4. 释放帧缓冲

    esp_camera_fb_return(fb);

    
    // 5. 控制发送频率

    vTaskDelay(pdMS_TO_TICKS(1));

  }

}
```





### 4. **异步WebSocket发送机制**

系统使用异步发送机制来避免阻塞：

```
esp_err_t ws_async_send_image(uint8_t *image_payload, size_t len) {

  httpd_ws_frame_t* ws_pkt = malloc(sizeof(httpd_ws_frame_t));

  ws_pkt->type = HTTPD_WS_TYPE_BINARY;  // 二进制数据类型

  ws_pkt->payload = image_payload;

  ws_pkt->len = len;

  
  esp_err_t ret = ws_async_send(ws_pkt);

  return ret;

}
```



### 5. **前端接收和显示**

前端JavaScript代码接收WebSocket数据并显示：

```
ws.value.onmessage = (event) => {

 if (typeof event.data === "string") {

  console.log("Received message:", event.data);

 } else {

  // 接收到二进制数据（JPEG图像）

  const blob = new Blob([event.data], { type: "image/jpeg" });

  if (currentImage.value) URL.revokeObjectURL(currentImage.value);

  currentImage.value = URL.createObjectURL(blob);  // 创建可显示的URL

 }

};
```

参考这里处理JPEG的数据



# 🌐 SparkBot Web Server 架构分析

## 📁 文件结构

```
main/server/
├── web_server.h          # 头文件，定义接口和结构体
└── web_server.c          # 主实现文件 (501行)
```

## 🏗️ 整体架构图

```
┌─────────────────────────────────────────────────────────────┐
│                    SparkBot Web Server                      │
├─────────────────────────────────────────────────────────────┤
│  📡 WiFi AP Module                                          │
│  ├── 热点创建 (esp-sparkbot-XXXX)                           │
│  ├── 网络配置 (192.168.4.1)                                │
│  └── 连接管理 (最多3个设备)                                  │
├─────────────────────────────────────────────────────────────┤
│  🌐 HTTP Server Module                                      │
│  ├── 静态文件服务                                           │
│  ├── API接口处理                                            │
│  ├── WebSocket支持                                          │
│  └── 跨域处理                                               │
├─────────────────────────────────────────────────────────────┤
│  📸 Camera Stream Module                                     │
│  ├── 实时视频流 (WebSocket)                                 │
│  ├── 单张图片捕获                                           │
│  ├── JPEG压缩处理                                           │
│  └── 质量控制                                               │
├─────────────────────────────────────────────────────────────┤
│  🎮 Control Module                                          │
│  ├── 运动控制指令                                           │
│  ├── 参数调节                                               │
│  └── 状态反馈                                               │
├─────────────────────────────────────────────────────────────┤
│  🔧 Utility Module                                          │
│  ├── 文件系统 (SPIFFS)                                      │
│  ├── 错误处理                                               │
│  ├── 内存管理                                               │
│  └── 日志记录                                               │
└─────────────────────────────────────────────────────────────┘
```

## 📋 模块详细分析

### 1. 📡 WiFi AP 模块 (第39-75行)

**功能**: 创建WiFi热点，提供网络接入

```c
void wifi_init_ap(void) {
    // 配置WiFi模式为AP
    wifi_mode_t wifi_mode = WIFI_MODE_AP;
    
    // 生成热点名称: esp-sparkbot-XXXX
    uint8_t mac[6];
    char ssid_str[20];
    esp_read_mac(mac, ESP_MAC_WIFI_SOFTAP);
    sprintf(ssid_str, "esp-sparkbot-%02X%02X", mac[4], mac[5]);
    
    // 配置热点参数
    wifi_config_t wifi_ap_config = {
        .ap = {
            .password = "",              // 无密码
            .channel = 8,               // 信道8
            .max_connection = 3,        // 最多3个连接
            .authmode = WIFI_AUTH_OPEN, // 开放认证
        },
    };
}
```

### 2. 🌐 HTTP服务器模块

#### A. 静态文件服务 (第256-281行)

```c
static esp_err_t file_get_handler(httpd_req_t *req) {
    // 文件路径处理
    snprintf(filepath, sizeof(filepath), "/webserver%s", req->uri);
    
    // 文件读取和发送
    FILE *file = fopen(filepath, "r");
    while ((len = fread(buffer, 1, sizeof(buffer), file)) > 0) {
        httpd_resp_send_chunk(req, buffer, len);
    }
}
```

#### B. MIME类型处理 (第225-254行)

```c
static esp_err_t set_content_type_from_file(httpd_req_t *req, const char *filename) {
    if (IS_FILE_EXT(filename, ".html")) {
        return httpd_resp_set_type(req, "text/html");
    } else if (IS_FILE_EXT(filename, ".jpeg")) {
        return httpd_resp_set_type(req, "image/jpeg");
    }
    // ... 更多类型
}
```



### 3. 📁 API接口总览

| 端点 | 方法 | 功能 | 返回类型 |
|------|------|------|----------|
| `/` | GET | 主页面 | HTML |
| `/ws` | GET | WebSocket连接 | WebSocket |
| `/stop` | GET | 停止视频流 | 重定向 |
| `/assets/*` | GET | 静态资源 | 各种类型 |
| `/img/*` | GET | 图片资源 | image/* |

### 4. 🔧 工具函数模块

#### A. 文件系统初始化 (第177-223行)

```c
static esp_err_t init_webserver_fs(void) {
    // SPIFFS文件系统挂载
    esp_vfs_spiffs_conf_t conf = {
        .base_path = "/webserver",
        .partition_label = "webserver",
        .max_files = 5,
        .format_if_mount_failed = true
    };
    esp_vfs_spiffs_register(&conf);
}
```

#### B. 连接监控 (第447-457行)

```c
void monitor_ws_connection(void *arg) {
    while (1) {
        time_t now = time(NULL);
        // 检查心跳超时 (5秒)
        if (ws_stream_task_running && (now - last_ping_time) > 5) {
            ESP_LOGW(TAG, "No heartbeat detected, stopping stream...");
            stop_ws_stream();
        }
        vTaskDelay(pdMS_TO_TICKS(220));
    }
}
```

## 🔄 数据流向图

```
手机/浏览器 ←→ WiFi热点 ←→ HTTP服务器 ←→ 摄像头模块
     ↑                                    ↓
     └─── WebSocket ←→ 视频流任务 ←→ JPEG编码器
     
控制指令: 手机 → WebSocket → 运动控制模块 → 硬件
视频流:   摄像头 → JPEG编码 → WebSocket → 手机显示
文件下载: 摄像头 → JPEG编码 → HTTP响应 → 手机保存
```

## 🚀 启动流程

1. **初始化阶段**:
   ```c
   wifi_init_ap()      // 创建WiFi热点
   start_webserver()   // 启动HTTP服务器
   ```

2. **运行阶段**:
   
   - HTTP服务器监听端口80
   - WebSocket等待连接
   - 监控任务检查连接状态
   
3. **连接建立**:
   
   - 客户端连接WebSocket
   - 自动启动视频流任务
   - 开始实时传输



